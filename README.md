# NicePlayTestTask

## Summary
Небольшая игра на Unity под Windows: 2D-симулятор про готовку еды на кухне с видом сбоку.
* _**Время выполнения:**_ 6 дней (2023-12-03 / 2023-12-08).
* **_Дополнительные задания:_** 10 / 13

## Check List
1. [x] **1. Комбо**. Хранятся в JSON, обрабатываются в `ComboHandler`.
2. [x] **2. Названия блюд**. Хранятся в JSON, обрабатываются в `RecipeHandler`.
3. [x] **3. Отображение счета и блюд**. `HUDController` обновляется в рамках одной игровой сессии.
4. [x] **4. Игровая область 16:9**. Используются `AspectRatioFitter` и `CanvasScaler`.
5. [x] **5. JSON-Конфиги**. В статичных данных хранятся и загружаются из аддрессаблов и `StaticDataService` JSON-ы для Ингредиентов (`IngredientStaticData`), Комбо (`ComboStaticData`) и Рецептов (`RecipeStaticData`).
6. [x] **6. Сброс уровня**. Сброс прогресса уровня происходит по нажатию на кнопку в HUD и хоткею **R**.
7. [x] **7. Сохранение и загрузка**. Прогресс уровня можно сохранить (хоткей **S**) и загрузить (хоткей **L**) в данные игрока. Если в момент сохранения прогресс на уровне нулевой -- сохранения не произойдет. Если в момент загрузке сохраненных данных нет -- сохранения не произойдет. В зависимости от наличия сохраненого прогресса в меню будет доступна кнопка **Продолжить игру**. _Важно_: прогресс не сохраняется при обновлении счета, только вручную по хоткеям.
8. [ ] **8. Содержимое кастрюли**.
9. [x] **9. Допустимый радиус клика**. Ингредиентам добавлены `CircleCollider2D`, все разделено на слои, а взаимодействие реализовано через Raycast.
10. [x] **10. Список всех возможных комбинаций**. Рассчитывается в отдельном окне `CombinationsWindow` которое вызывается в меню по кнопке, а на уровнях - по хоткею **T**.
11. [ ] **11. Шейдер выделения при ховере**.
12. [x] **12. Assembly definitions**. Asmdef-ы организовывал для стороних библиотек (внутри папки `Libs`) и для кастомных компонентов UI. В геймплейных компонентах и смервисах они только мешают.
13. [ ] **13. Анимация тления углей**.

## Tech stack
#### Unity packages
* Addressables 1.21.19
* InputSystem 1.7.0
#### Third-party libs
* Zenject
* DOTween
#### Tools
* Odin Inspector
* PlayerPrefsEditor

## Project Structure
Проект разделен на три части:
* **Infrastructure** - сервисы, провайдеры, инсталлеры;
* **Meta** - меню, настройки и прочее;
* **Gameplay** - гаджеты, UI для управления ими.

Структура проекта перекомпонована согласно частям и функциональностям, а не по типу ассетов.
При таком подходе концентрация разработчика на одной текущей фиче или модуле поддерживается отдельной деректорией, содержащей все необходимые ассеты.
Поддерживается аккуратная организация решения в Rider / VS.

Сторонние плагины и библиотеки вынесены в папку `Libs`, кодовая база самого проекта - в `NicePlayTestTask`.

В "устойчивых разделах" проекта, имеющих однонаправленные зависимости к сервисным и геймплейным модулям,
добавлены `AsssemblyDefenition`'ы для ускорения перекомпиляции при разработке.
В геймплейных модулях их использовать не стоит - будут кросс-зависимости.

## Архитектурные Принципы
* Архитектура - **сервисный** подход
* Геймплей - **компонентный** подход
* Фабрики:
    - `IngredientFactory` - для создания и конструирования игровых объектов (TODO), сейчас инициализируется (`Initialize`) из `LevelInstaller`;
    - `UIFactory` - для создания и конструирования UI-элементов (окна комбинаций, UI-root'a, HUD'a) и проброса в них зависимостей.

Каждый сервис, реализующий некоторую ответственность в проекте, регистрируется в DI контейнере по
интерфейсу и передается как зависимость (_LSP_, _DIP_) в `конструктор`ы или в специальные методы `Construct` с атрибутом `Inject` для `MonoBehavior`'ов.

Некоторые сервисы (например - remote (TODO) или `GameStateMachine`) требуют инициализации, поэтому реализуют метод `Initialize` Zenject-интерфейса `IInitializable`.
Что отражено в их регистрации `BindInterfacesAndSelfTo` в инсталлере `InfrastructureInstaller` в `ProjectContext`.

Поведение игровых объектов в геймплее собирается из нескольких небольших компонентов (_SRP_). Компоненты настраиваются фабрикой при создании игрового объекта.
Фабрика при этом пользуется сервисами, полученными как зависимости. При необходимости может выполниться инъекция в создаваемый игровой объект. Для этого
фабрики получают DI-контейнер как зависимость (и только они, согласно принципам Zenject).

## GameStateMachine
Используется для управления жизненным циклом игры. Описание состояний (в порядке перехода):
1. `Bootstrap`. Инициализация и ожидание статичных данных игры
2. `LoadPogressState`. Загрузка прогрресса игрока.
3. `LoadMetaState`. Загрузка и переход к меню или мета-геймплею.
4. `LoadLevelState`. Загрузка уровня и его ресурсов. Инициализация мира и UI.
5. `GameLoopState`. Взаимодействие с игровым миром. На выходе (рестарте) очищаются фабрики и освобождаются ресурсы.

Для более удобного конструирования состояний и во избежании взрыва конструктора GSM написана `StateFactory`.

## Примечания
* Вместо привычных RSG.Promises для сборки окон воспользовался C#-tasks, обернув _TAP_ обратно в _EAP_, чтобы отслеживать завершение взаимодействия с окном.
* Пргресс игрока на отдельном уровне отслеживается с помощью суб-контейнера `SceneContext` и `LevelProgressWatcher`.
* Игровой прогресс хранится в PlayerPrefs ввиде json.
* Обработка и обсчет блюд при готовке реалтзованы на _Chain Of Responsibility_ шаблоне, отдельные `Handler`'ы (их геймобджекты) можно отключать из обработки прямо в рантайме.
* Логику следования ингредиента за курсором сделал параметризированно, через `DOTween`, чтобы было проще тюнить.


